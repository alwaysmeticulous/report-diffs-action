{"mappings":"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","sources":["<anon>","node_modules/@tootallnate/quickjs-emscripten/dist/module.js","node_modules/@tootallnate/quickjs-emscripten/ts/module.ts","node_modules/@tootallnate/quickjs-emscripten/dist/runtime.js","node_modules/@tootallnate/quickjs-emscripten/ts/runtime.ts","node_modules/@tootallnate/quickjs-emscripten/dist/context.js","node_modules/@tootallnate/quickjs-emscripten/ts/context.ts","node_modules/@tootallnate/quickjs-emscripten/dist/memory.js","node_modules/@tootallnate/quickjs-emscripten/ts/memory.ts","node_modules/@tootallnate/quickjs-emscripten/dist/types.js","node_modules/@tootallnate/quickjs-emscripten/ts/types.ts","node_modules/@tootallnate/quickjs-emscripten/dist/types-ffi.js","node_modules/@tootallnate/quickjs-emscripten/ts/types-ffi.ts"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"6TlVH\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSWASMModule = module.exports.applyModuleEvalRuntimeOptions = module.exports.applyBaseRuntimeOptions = module.exports.QuickJSModuleCallbacks = void 0;\n\nvar $6g0BN = parcelRequire(\"6g0BN\");\n\nvar $1ODqT = parcelRequire(\"1ODqT\");\n\nvar $bi2gA = parcelRequire(\"bi2gA\");\n\nvar $dHRyi = parcelRequire(\"dHRyi\");\n\nvar $b4QHs = parcelRequire(\"b4QHs\");\nclass $5048e3e70162010f$var$QuickJSEmscriptenModuleCallbacks {\n    constructor(args){\n        this.callFunction = args.callFunction;\n        this.shouldInterrupt = args.shouldInterrupt;\n        this.loadModuleSource = args.loadModuleSource;\n        this.normalizeModule = args.normalizeModule;\n    }\n}\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */ class $5048e3e70162010f$var$QuickJSModuleCallbacks {\n    constructor(module){\n        this.contextCallbacks = new Map();\n        this.runtimeCallbacks = new Map();\n        this.suspendedCount = 0;\n        this.cToHostCallbacks = new $5048e3e70162010f$var$QuickJSEmscriptenModuleCallbacks({\n            callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id)=>this.handleAsyncify(asyncify, ()=>{\n                    try {\n                        const vm = this.contextCallbacks.get(ctx);\n                        if (!vm) throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`);\n                        return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);\n                    } catch (error) {\n                        console.error(\"[C to host error: returning null]\", error);\n                        return 0;\n                    }\n                }),\n            shouldInterrupt: (asyncify, rt)=>this.handleAsyncify(asyncify, ()=>{\n                    try {\n                        const vm = this.runtimeCallbacks.get(rt);\n                        if (!vm) throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`);\n                        return vm.shouldInterrupt(rt);\n                    } catch (error) {\n                        console.error(\"[C to host interrupt: returning error]\", error);\n                        return 1;\n                    }\n                }),\n            loadModuleSource: (asyncify, rt, ctx, moduleName)=>this.handleAsyncify(asyncify, ()=>{\n                    try {\n                        const runtimeCallbacks = this.runtimeCallbacks.get(rt);\n                        if (!runtimeCallbacks) throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);\n                        const loadModule = runtimeCallbacks.loadModuleSource;\n                        if (!loadModule) throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);\n                        return loadModule(rt, ctx, moduleName);\n                    } catch (error) {\n                        console.error(\"[C to host module loader error: returning null]\", error);\n                        return 0;\n                    }\n                }),\n            normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName)=>this.handleAsyncify(asyncify, ()=>{\n                    try {\n                        const runtimeCallbacks = this.runtimeCallbacks.get(rt);\n                        if (!runtimeCallbacks) throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);\n                        const normalizeModule = runtimeCallbacks.normalizeModule;\n                        if (!normalizeModule) throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);\n                        return normalizeModule(rt, ctx, moduleBaseName, moduleName);\n                    } catch (error) {\n                        console.error(\"[C to host module loader error: returning null]\", error);\n                        return 0;\n                    }\n                })\n        });\n        this.module = module;\n        this.module.callbacks = this.cToHostCallbacks;\n    }\n    setRuntimeCallbacks(rt, callbacks) {\n        this.runtimeCallbacks.set(rt, callbacks);\n    }\n    deleteRuntime(rt) {\n        this.runtimeCallbacks.delete(rt);\n    }\n    setContextCallbacks(ctx, callbacks) {\n        this.contextCallbacks.set(ctx, callbacks);\n    }\n    deleteContext(ctx) {\n        this.contextCallbacks.delete(ctx);\n    }\n    handleAsyncify(asyncify, fn) {\n        if (asyncify) // We must always call asyncify.handleSync around our function.\n        // This allows asyncify to resume suspended execution on the second call.\n        // Asyncify internally can detect sync behavior, and avoid suspending.\n        return asyncify.handleSleep((done)=>{\n            try {\n                const result = fn();\n                if (!(result instanceof Promise)) {\n                    (0, $6g0BN.debugLog)(\"asyncify.handleSleep: not suspending:\", result);\n                    done(result);\n                    return;\n                }\n                // Is promise, we intend to suspend.\n                if (this.suspended) throw new $1ODqT.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`);\n                else {\n                    this.suspended = new $1ODqT.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);\n                    (0, $6g0BN.debugLog)(\"asyncify.handleSleep: suspending:\", this.suspended);\n                }\n                result.then((resolvedResult)=>{\n                    this.suspended = undefined;\n                    (0, $6g0BN.debugLog)(\"asyncify.handleSleep: resolved:\", resolvedResult);\n                    done(resolvedResult);\n                }, (error)=>{\n                    (0, $6g0BN.debugLog)(\"asyncify.handleSleep: rejected:\", error);\n                    console.error(\"QuickJS: cannot handle error in suspended function\", error);\n                    this.suspended = undefined;\n                });\n            } catch (error) {\n                (0, $6g0BN.debugLog)(\"asyncify.handleSleep: error:\", error);\n                this.suspended = undefined;\n                throw error;\n            }\n        });\n        // No asyncify - we should never return a promise.\n        const value = fn();\n        if (value instanceof Promise) throw new Error(\"Promise return value not supported in non-asyncify context.\");\n        return value;\n    }\n}\nmodule.exports.QuickJSModuleCallbacks = $5048e3e70162010f$var$QuickJSModuleCallbacks;\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */ function $5048e3e70162010f$var$applyBaseRuntimeOptions(runtime, options) {\n    if (options.interruptHandler) runtime.setInterruptHandler(options.interruptHandler);\n    if (options.maxStackSizeBytes !== undefined) runtime.setMaxStackSize(options.maxStackSizeBytes);\n    if (options.memoryLimitBytes !== undefined) runtime.setMemoryLimit(options.memoryLimitBytes);\n}\nmodule.exports.applyBaseRuntimeOptions = $5048e3e70162010f$var$applyBaseRuntimeOptions;\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */ function $5048e3e70162010f$var$applyModuleEvalRuntimeOptions(runtime, options) {\n    if (options.moduleLoader) runtime.setModuleLoader(options.moduleLoader);\n    if (options.shouldInterrupt) runtime.setInterruptHandler(options.shouldInterrupt);\n    if (options.memoryLimitBytes !== undefined) runtime.setMemoryLimit(options.memoryLimitBytes);\n    if (options.maxStackSizeBytes !== undefined) runtime.setMaxStackSize(options.maxStackSizeBytes);\n}\nmodule.exports.applyModuleEvalRuntimeOptions = $5048e3e70162010f$var$applyModuleEvalRuntimeOptions;\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */ class $5048e3e70162010f$var$QuickJSWASMModule {\n    /** @private */ constructor(module, ffi){\n        this.module = module;\n        this.ffi = ffi;\n        this.callbacks = new $5048e3e70162010f$var$QuickJSModuleCallbacks(module);\n    }\n    /**\n     * Create a runtime.\n     * Use the runtime to set limits on CPU and memory usage and configure module\n     * loading for one or more [[QuickJSContext]]s inside the runtime.\n     */ newRuntime(options = {}) {\n        const rt = new $bi2gA.Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr)=>{\n            this.callbacks.deleteRuntime(rt_ptr);\n            this.ffi.QTS_FreeRuntime(rt_ptr);\n        });\n        const runtime = new $dHRyi.QuickJSRuntime({\n            module: this.module,\n            callbacks: this.callbacks,\n            ffi: this.ffi,\n            rt: rt\n        });\n        $5048e3e70162010f$var$applyBaseRuntimeOptions(runtime, options);\n        if (options.moduleLoader) runtime.setModuleLoader(options.moduleLoader);\n        return runtime;\n    }\n    /**\n     * A simplified API to create a new [[QuickJSRuntime]] and a\n     * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n     * be disposed when the context is disposed.\n     */ newContext(options = {}) {\n        const runtime = this.newRuntime();\n        const context = runtime.newContext({\n            ...options,\n            ownedLifetimes: (0, $b4QHs.concat)(runtime, options.ownedLifetimes)\n        });\n        runtime.context = context;\n        return context;\n    }\n    /**\n     * One-off evaluate code without needing to create a [[QuickJSRuntime]] or\n     * [[QuickJSContext]] explicitly.\n     *\n     * To protect against infinite loops, use the `shouldInterrupt` option. The\n     * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.\n     *\n     * If you need more control over how the code executes, create a\n     * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with\n     * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its\n     * [[QuickJSContext.evalCode]] method.\n     *\n     * Asynchronous callbacks may not run during the first call to `evalCode`. If\n     * you need to work with async code inside QuickJS, create a runtime and use\n     * [[QuickJSRuntime.executePendingJobs]].\n     *\n     * @returns The result is coerced to a native Javascript value using JSON\n     * serialization, so properties and values unsupported by JSON will be dropped.\n     *\n     * @throws If `code` throws during evaluation, the exception will be\n     * converted into a native Javascript value and thrown.\n     *\n     * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n     * with name `\"InternalError\"` and  message `\"interrupted\"`.\n     */ evalCode(code, options = {}) {\n        return $bi2gA.Scope.withScope((scope)=>{\n            const vm = scope.manage(this.newContext());\n            $5048e3e70162010f$var$applyModuleEvalRuntimeOptions(vm.runtime, options);\n            const result = vm.evalCode(code, \"eval.js\");\n            if (options.memoryLimitBytes !== undefined) // Remove memory limit so we can dump the result without exceeding it.\n            vm.runtime.setMemoryLimit(-1);\n            if (result.error) {\n                const error = vm.dump(scope.manage(result.error));\n                throw error;\n            }\n            const value = vm.dump(scope.manage(result.value));\n            return value;\n        });\n    }\n    /**\n     * Get a low-level interface to the QuickJS functions in this WebAssembly\n     * module.\n     * @experimental\n     * @unstable No warranty is provided with this API. It could change at any time.\n     * @private\n     */ getFFI() {\n        return this.ffi;\n    }\n}\nmodule.exports.QuickJSWASMModule = $5048e3e70162010f$var$QuickJSWASMModule;\n\n});\nparcelRegister(\"dHRyi\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSRuntime = void 0;\n\nvar $1kGDh = parcelRequire(\"1kGDh\");\n\nvar $6vZNq = parcelRequire(\"6vZNq\");\n\nvar $6g0BN = parcelRequire(\"6g0BN\");\n\nvar $1ODqT = parcelRequire(\"1ODqT\");\n\nvar $bi2gA = parcelRequire(\"bi2gA\");\n\nvar $2CmkI = parcelRequire(\"2CmkI\");\n\nvar $b4QHs = parcelRequire(\"b4QHs\");\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with [[setInterruptHandler]]\n * (called regularly while the interpreter runs), [[setMemoryLimit]], and\n * [[setMaxStackSize]].\n * Use [[computeMemoryUsage]] or [[dumpMemoryUsage]] to guide memory limit\n * tuning.\n *\n * Configure ES module loading with [[setModuleLoader]].\n */ class $9fa8d4daff440008$var$QuickJSRuntime {\n    /** @private */ constructor(args){\n        /** @private */ this.scope = new $bi2gA.Scope();\n        /** @private */ this.contextMap = new Map();\n        this.cToHostCallbacks = {\n            shouldInterrupt: (rt)=>{\n                if (rt !== this.rt.value) throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\");\n                const fn = this.interruptHandler;\n                if (!fn) throw new Error(\"QuickJSContext had no interrupt handler\");\n                return fn(this) ? 1 : 0;\n            },\n            loadModuleSource: (0, $1kGDh.maybeAsyncFn)(this, function*(awaited, rt, ctx, moduleName) {\n                const moduleLoader = this.moduleLoader;\n                if (!moduleLoader) throw new Error(\"Runtime has no module loader\");\n                if (rt !== this.rt.value) throw new Error(\"Runtime pointer mismatch\");\n                const context = this.contextMap.get(ctx) ?? this.newContext({\n                    contextPointer: ctx\n                });\n                try {\n                    const result = yield* awaited(moduleLoader(moduleName, context));\n                    if (typeof result === \"object\" && \"error\" in result && result.error) {\n                        (0, $6g0BN.debugLog)(\"cToHostLoadModule: loader returned error\", result.error);\n                        throw result.error;\n                    }\n                    const moduleSource = typeof result === \"string\" ? result : \"value\" in result ? result.value : result;\n                    return this.memory.newHeapCharPointer(moduleSource).value;\n                } catch (error) {\n                    (0, $6g0BN.debugLog)(\"cToHostLoadModule: caught error\", error);\n                    context.throw(error);\n                    return 0;\n                }\n            }),\n            normalizeModule: (0, $1kGDh.maybeAsyncFn)(this, function*(awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n                const moduleNormalizer = this.moduleNormalizer;\n                if (!moduleNormalizer) throw new Error(\"Runtime has no module normalizer\");\n                if (rt !== this.rt.value) throw new Error(\"Runtime pointer mismatch\");\n                const context = this.contextMap.get(ctx) ?? this.newContext({\n                    /* TODO: Does this happen? Are we responsible for disposing? I don't think so */ contextPointer: ctx\n                });\n                try {\n                    const result = yield* awaited(moduleNormalizer(baseModuleName, moduleNameRequest, context));\n                    if (typeof result === \"object\" && \"error\" in result && result.error) {\n                        (0, $6g0BN.debugLog)(\"cToHostNormalizeModule: normalizer returned error\", result.error);\n                        throw result.error;\n                    }\n                    const name = typeof result === \"string\" ? result : result.value;\n                    return context.getMemory(this.rt.value).newHeapCharPointer(name).value;\n                } catch (error) {\n                    (0, $6g0BN.debugLog)(\"normalizeModule: caught error\", error);\n                    context.throw(error);\n                    return 0;\n                }\n            })\n        };\n        args.ownedLifetimes?.forEach((lifetime)=>this.scope.manage(lifetime));\n        this.module = args.module;\n        this.memory = new $2CmkI.ModuleMemory(this.module);\n        this.ffi = args.ffi;\n        this.rt = args.rt;\n        this.callbacks = args.callbacks;\n        this.scope.manage(this.rt);\n        this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks);\n        this.executePendingJobs = this.executePendingJobs.bind(this);\n    }\n    get alive() {\n        return this.scope.alive;\n    }\n    dispose() {\n        return this.scope.dispose();\n    }\n    newContext(options = {}) {\n        if (options.intrinsics && options.intrinsics !== $b4QHs.DefaultIntrinsics) throw new Error(\"TODO: Custom intrinsics are not supported yet\");\n        const ctx = new $bi2gA.Lifetime(options.contextPointer || this.ffi.QTS_NewContext(this.rt.value), undefined, (ctx_ptr)=>{\n            this.contextMap.delete(ctx_ptr);\n            this.callbacks.deleteContext(ctx_ptr);\n            this.ffi.QTS_FreeContext(ctx_ptr);\n        });\n        const context = new $6vZNq.QuickJSContext({\n            module: this.module,\n            ctx: ctx,\n            ffi: this.ffi,\n            rt: this.rt,\n            ownedLifetimes: options.ownedLifetimes,\n            runtime: this,\n            callbacks: this.callbacks\n        });\n        this.contextMap.set(ctx.value, context);\n        return context;\n    }\n    /**\n     * Set the loader for EcmaScript modules requested by any context in this\n     * runtime.\n     *\n     * The loader can be removed with [[removeModuleLoader]].\n     */ setModuleLoader(moduleLoader, moduleNormalizer) {\n        this.moduleLoader = moduleLoader;\n        this.moduleNormalizer = moduleNormalizer;\n        this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);\n    }\n    /**\n     * Remove the the loader set by [[setModuleLoader]]. This disables module loading.\n     */ removeModuleLoader() {\n        this.moduleLoader = undefined;\n        this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);\n    }\n    // Runtime management -------------------------------------------------------\n    /**\n     * In QuickJS, promises and async functions create pendingJobs. These do not execute\n     * immediately and need to be run by calling [[executePendingJobs]].\n     *\n     * @return true if there is at least one pendingJob queued up.\n     */ hasPendingJob() {\n        return Boolean(this.ffi.QTS_IsJobPending(this.rt.value));\n    }\n    /**\n     * Set a callback which is regularly called by the QuickJS engine when it is\n     * executing code. This callback can be used to implement an execution\n     * timeout.\n     *\n     * The interrupt handler can be removed with [[removeInterruptHandler]].\n     */ setInterruptHandler(cb) {\n        const prevInterruptHandler = this.interruptHandler;\n        this.interruptHandler = cb;\n        if (!prevInterruptHandler) this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);\n    }\n    /**\n     * Remove the interrupt handler, if any.\n     * See [[setInterruptHandler]].\n     */ removeInterruptHandler() {\n        if (this.interruptHandler) {\n            this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value);\n            this.interruptHandler = undefined;\n        }\n    }\n    /**\n     * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n     * executed (default all pendingJobs), the queue is exhausted, or the runtime\n     * encounters an exception.\n     *\n     * In QuickJS, promises and async functions *inside the runtime* create\n     * pendingJobs. These do not execute immediately and need to triggered to run.\n     *\n     * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n     * at most `maxJobsToExecute` before returning.\n     *\n     * @return On success, the number of executed jobs. On error, the exception\n     * that stopped execution, and the context it occurred in. Note that\n     * executePendingJobs will not normally return errors thrown inside async\n     * functions or rejected promises. Those errors are available by calling\n     * [[resolvePromise]] on the promise handle returned by the async function.\n     */ executePendingJobs(maxJobsToExecute = -1) {\n        const ctxPtrOut = this.memory.newMutablePointerArray(1);\n        const valuePtr = this.ffi.QTS_ExecutePendingJob(this.rt.value, maxJobsToExecute ?? -1, ctxPtrOut.value.ptr);\n        const ctxPtr = ctxPtrOut.value.typedArray[0];\n        ctxPtrOut.dispose();\n        if (ctxPtr === 0) {\n            // No jobs executed.\n            this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr);\n            return {\n                value: 0\n            };\n        }\n        const context = this.contextMap.get(ctxPtr) ?? this.newContext({\n            contextPointer: ctxPtr\n        });\n        const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr);\n        const typeOfRet = context.typeof(resultValue);\n        if (typeOfRet === \"number\") {\n            const executedJobs = context.getNumber(resultValue);\n            resultValue.dispose();\n            return {\n                value: executedJobs\n            };\n        } else {\n            const error = Object.assign(resultValue, {\n                context: context\n            });\n            return {\n                error: error\n            };\n        }\n    }\n    /**\n     * Set the max memory this runtime can allocate.\n     * To remove the limit, set to `-1`.\n     */ setMemoryLimit(limitBytes) {\n        if (limitBytes < 0 && limitBytes !== -1) throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\");\n        this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes);\n    }\n    /**\n     * Compute memory usage for this runtime. Returns the result as a handle to a\n     * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.\n     * Calling this method will allocate more memory inside the runtime. The information\n     * is accurate as of just before the call to `computeMemoryUsage`.\n     * For a human-digestible representation, see [[dumpMemoryUsage]].\n     */ computeMemoryUsage() {\n        const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value);\n        return serviceContextMemory.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value));\n    }\n    /**\n     * @returns a human-readable description of memory usage in this runtime.\n     * For programmatic access to this information, see [[computeMemoryUsage]].\n     */ dumpMemoryUsage() {\n        return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));\n    }\n    /**\n     * Set the max stack size for this runtime, in bytes.\n     * To remove the limit, set to `0`.\n     */ setMaxStackSize(stackSize) {\n        if (stackSize < 0) throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\");\n        this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize);\n    }\n    /**\n     * Assert that `handle` is owned by this runtime.\n     * @throws QuickJSWrongOwner if owned by a different runtime.\n     */ assertOwned(handle) {\n        if (handle.owner && handle.owner.rt !== this.rt) throw new $1ODqT.QuickJSWrongOwner(`Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`);\n    }\n    getSystemContext() {\n        if (!this.context) // We own this context and should dispose of it.\n        this.context = this.scope.manage(this.newContext());\n        return this.context;\n    }\n}\nmodule.exports.QuickJSRuntime = $9fa8d4daff440008$var$QuickJSRuntime;\n\n});\nparcelRegister(\"6vZNq\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSContext = void 0;\n\nvar $6g0BN = parcelRequire(\"6g0BN\");\n\nvar $hHSpR = parcelRequire(\"hHSpR\");\n\nvar $1ODqT = parcelRequire(\"1ODqT\");\n\nvar $bi2gA = parcelRequire(\"bi2gA\");\n\nvar $2CmkI = parcelRequire(\"2CmkI\");\n\nvar $b4QHs = parcelRequire(\"b4QHs\");\n/**\n * @private\n */ class $4be592c2b41fac6d$var$ContextMemory extends $2CmkI.ModuleMemory {\n    /** @private */ constructor(args){\n        super(args.module);\n        this.scope = new $bi2gA.Scope();\n        this.copyJSValue = (ptr)=>{\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);\n        };\n        this.freeJSValue = (ptr)=>{\n            this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);\n        };\n        args.ownedLifetimes?.forEach((lifetime)=>this.scope.manage(lifetime));\n        this.owner = args.owner;\n        this.module = args.module;\n        this.ffi = args.ffi;\n        this.rt = args.rt;\n        this.ctx = this.scope.manage(args.ctx);\n    }\n    get alive() {\n        return this.scope.alive;\n    }\n    dispose() {\n        return this.scope.dispose();\n    }\n    /**\n     * Track `lifetime` so that it is disposed when this scope is disposed.\n     */ manage(lifetime) {\n        return this.scope.manage(lifetime);\n    }\n    consumeJSCharPointer(ptr) {\n        const str = this.module.UTF8ToString(ptr);\n        this.ffi.QTS_FreeCString(this.ctx.value, ptr);\n        return str;\n    }\n    heapValueHandle(ptr) {\n        return new $bi2gA.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);\n    }\n}\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */ // TODO: Manage own callback registration\nclass $4be592c2b41fac6d$var$QuickJSContext {\n    /**\n     * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n     */ constructor(args){\n        /** @private */ this._undefined = undefined;\n        /** @private */ this._null = undefined;\n        /** @private */ this._false = undefined;\n        /** @private */ this._true = undefined;\n        /** @private */ this._global = undefined;\n        /** @private */ this._BigInt = undefined;\n        /** @private */ this.fnNextId = -32768; // min value of signed 16bit int used by Quickjs\n        /** @private */ this.fnMaps = new Map();\n        /**\n         * @hidden\n         */ this.cToHostCallbacks = {\n            callFunction: (ctx, this_ptr, argc, argv, fn_id)=>{\n                if (ctx !== this.ctx.value) throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\");\n                const fn = this.getFunction(fn_id);\n                if (!fn) // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n                throw new Error(`QuickJSContext had no callback with id ${fn_id}`);\n                return $bi2gA.Scope.withScopeMaybeAsync(this, function*(awaited, scope) {\n                    const thisHandle = scope.manage(new $bi2gA.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n                    const argHandles = new Array(argc);\n                    for(let i = 0; i < argc; i++){\n                        const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i);\n                        argHandles[i] = scope.manage(new $bi2gA.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n                    }\n                    try {\n                        const result = yield* awaited(fn.apply(thisHandle, argHandles));\n                        if (result) {\n                            if (\"error\" in result && result.error) {\n                                (0, $6g0BN.debugLog)(\"throw error\", result.error);\n                                throw result.error;\n                            }\n                            const handle = scope.manage(result instanceof $bi2gA.Lifetime ? result : result.value);\n                            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value);\n                        }\n                        return 0;\n                    } catch (error) {\n                        return this.errorToHandle(error).consume((errorHandle)=>this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));\n                    }\n                });\n            }\n        };\n        this.runtime = args.runtime;\n        this.module = args.module;\n        this.ffi = args.ffi;\n        this.rt = args.rt;\n        this.ctx = args.ctx;\n        this.memory = new $4be592c2b41fac6d$var$ContextMemory({\n            ...args,\n            owner: this.runtime\n        });\n        args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);\n        this.dump = this.dump.bind(this);\n        this.getString = this.getString.bind(this);\n        this.getNumber = this.getNumber.bind(this);\n        this.resolvePromise = this.resolvePromise.bind(this);\n    }\n    // @implement Disposable ----------------------------------------------------\n    get alive() {\n        return this.memory.alive;\n    }\n    /**\n     * Dispose of this VM's underlying resources.\n     *\n     * @throws Calling this method without disposing of all created handles\n     * will result in an error.\n     */ dispose() {\n        this.memory.dispose();\n    }\n    // Globals ------------------------------------------------------------------\n    /**\n     * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n     */ get undefined() {\n        if (this._undefined) return this._undefined;\n        // Undefined is a constant, immutable value in QuickJS.\n        const ptr = this.ffi.QTS_GetUndefined();\n        return this._undefined = new $bi2gA.StaticLifetime(ptr);\n    }\n    /**\n     * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n     */ get null() {\n        if (this._null) return this._null;\n        // Null is a constant, immutable value in QuickJS.\n        const ptr = this.ffi.QTS_GetNull();\n        return this._null = new $bi2gA.StaticLifetime(ptr);\n    }\n    /**\n     * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n     */ get true() {\n        if (this._true) return this._true;\n        // True is a constant, immutable value in QuickJS.\n        const ptr = this.ffi.QTS_GetTrue();\n        return this._true = new $bi2gA.StaticLifetime(ptr);\n    }\n    /**\n     * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n     */ get false() {\n        if (this._false) return this._false;\n        // False is a constant, immutable value in QuickJS.\n        const ptr = this.ffi.QTS_GetFalse();\n        return this._false = new $bi2gA.StaticLifetime(ptr);\n    }\n    /**\n     * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n     * A handle to the global object inside the interpreter.\n     * You can set properties to create global variables.\n     */ get global() {\n        if (this._global) return this._global;\n        // The global is a JSValue, but since it's lifetime is as long as the VM's,\n        // we should manage it.\n        const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);\n        // Automatically clean up this reference when we dispose\n        this.memory.manage(this.memory.heapValueHandle(ptr));\n        // This isn't technically a static lifetime, but since it has the same\n        // lifetime as the VM, it's okay to fake one since when the VM is\n        // disposed, no other functions will accept the value.\n        this._global = new $bi2gA.StaticLifetime(ptr, this.runtime);\n        return this._global;\n    }\n    // New values ---------------------------------------------------------------\n    /**\n     * Converts a Javascript number into a QuickJS value.\n     */ newNumber(num) {\n        return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));\n    }\n    /**\n     * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n     */ newString(str) {\n        const ptr = this.memory.newHeapCharPointer(str).consume((charHandle)=>this.ffi.QTS_NewString(this.ctx.value, charHandle.value));\n        return this.memory.heapValueHandle(ptr);\n    }\n    /**\n     * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n     * No two symbols created with this function will be the same value.\n     */ newUniqueSymbol(description) {\n        const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\";\n        const ptr = this.memory.newHeapCharPointer(key).consume((charHandle)=>this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));\n        return this.memory.heapValueHandle(ptr);\n    }\n    /**\n     * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n     * All symbols created with the same key will be the same value.\n     */ newSymbolFor(key) {\n        const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\";\n        const ptr = this.memory.newHeapCharPointer(description).consume((charHandle)=>this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));\n        return this.memory.heapValueHandle(ptr);\n    }\n    /**\n     * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n     */ newBigInt(num) {\n        if (!this._BigInt) {\n            const bigIntHandle = this.getProp(this.global, \"BigInt\");\n            this.memory.manage(bigIntHandle);\n            this._BigInt = new $bi2gA.StaticLifetime(bigIntHandle.value, this.runtime);\n        }\n        const bigIntHandle = this._BigInt;\n        const asString = String(num);\n        return this.newString(asString).consume((handle)=>this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)));\n    }\n    /**\n     * `{}`.\n     * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n     *\n     * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n     */ newObject(prototype) {\n        if (prototype) this.runtime.assertOwned(prototype);\n        const ptr = prototype ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value) : this.ffi.QTS_NewObject(this.ctx.value);\n        return this.memory.heapValueHandle(ptr);\n    }\n    /**\n     * `[]`.\n     * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n     */ newArray() {\n        const ptr = this.ffi.QTS_NewArray(this.ctx.value);\n        return this.memory.heapValueHandle(ptr);\n    }\n    newPromise(value) {\n        const deferredPromise = $bi2gA.Scope.withScope((scope)=>{\n            const mutablePointerArray = scope.manage(this.memory.newMutablePointerArray(2));\n            const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);\n            const promiseHandle = this.memory.heapValueHandle(promisePtr);\n            const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map((jsvaluePtr)=>this.memory.heapValueHandle(jsvaluePtr));\n            return new $hHSpR.QuickJSDeferredPromise({\n                context: this,\n                promiseHandle: promiseHandle,\n                resolveHandle: resolveHandle,\n                rejectHandle: rejectHandle\n            });\n        });\n        if (value && typeof value === \"function\") value = new Promise(value);\n        if (value) Promise.resolve(value).then(deferredPromise.resolve, (error)=>error instanceof $bi2gA.Lifetime ? deferredPromise.reject(error) : this.newError(error).consume(deferredPromise.reject));\n        return deferredPromise;\n    }\n    /**\n     * Convert a Javascript function into a QuickJS function value.\n     * See [[VmFunctionImplementation]] for more details.\n     *\n     * A [[VmFunctionImplementation]] should not free its arguments or its return\n     * value. A VmFunctionImplementation should also not retain any references to\n     * its return value.\n     *\n     * To implement an async function, create a promise with [[newPromise]], then\n     * return the deferred promise handle from `deferred.handle` from your\n     * function implementation:\n     *\n     * ```\n     * const deferred = vm.newPromise()\n     * someNativeAsyncFunction().then(deferred.resolve)\n     * return deferred.handle\n     * ```\n     */ newFunction(name, fn) {\n        const fnId = ++this.fnNextId;\n        this.setFunction(fnId, fn);\n        return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name));\n    }\n    newError(error) {\n        const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));\n        if (error && typeof error === \"object\") {\n            if (error.name !== undefined) this.newString(error.name).consume((handle)=>this.setProp(errorHandle, \"name\", handle));\n            if (error.message !== undefined) this.newString(error.message).consume((handle)=>this.setProp(errorHandle, \"message\", handle));\n        } else if (typeof error === \"string\") this.newString(error).consume((handle)=>this.setProp(errorHandle, \"message\", handle));\n        else if (error !== undefined) // This isn't supported in the type signature but maybe it will make life easier.\n        this.newString(String(error)).consume((handle)=>this.setProp(errorHandle, \"message\", handle));\n        return errorHandle;\n    }\n    // Read values --------------------------------------------------------------\n    /**\n     * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n     *\n     * @remarks\n     * Does not support BigInt values correctly.\n     */ typeof(handle) {\n        this.runtime.assertOwned(handle);\n        return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value));\n    }\n    /**\n     * Converts `handle` into a Javascript number.\n     * @returns `NaN` on error, otherwise a `number`.\n     */ getNumber(handle) {\n        this.runtime.assertOwned(handle);\n        return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value);\n    }\n    /**\n     * Converts `handle` to a Javascript string.\n     */ getString(handle) {\n        this.runtime.assertOwned(handle);\n        return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value));\n    }\n    /**\n     * Converts `handle` into a Javascript symbol. If the symbol is in the global\n     * registry in the guest, it will be created with Symbol.for on the host.\n     */ getSymbol(handle) {\n        this.runtime.assertOwned(handle);\n        const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value));\n        const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value);\n        return isGlobal ? Symbol.for(key) : Symbol(key);\n    }\n    /**\n     * Converts `handle` to a Javascript bigint.\n     */ getBigInt(handle) {\n        this.runtime.assertOwned(handle);\n        const asString = this.getString(handle);\n        return BigInt(asString);\n    }\n    /**\n     * `Promise.resolve(value)`.\n     * Convert a handle containing a Promise-like value inside the VM into an\n     * actual promise on the host.\n     *\n     * @remarks\n     * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n     *\n     * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n     */ resolvePromise(promiseLikeHandle) {\n        this.runtime.assertOwned(promiseLikeHandle);\n        const vmResolveResult = $bi2gA.Scope.withScope((scope)=>{\n            const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"));\n            const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"));\n            return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);\n        });\n        if (vmResolveResult.error) return Promise.resolve(vmResolveResult);\n        return new Promise((resolve)=>{\n            $bi2gA.Scope.withScope((scope)=>{\n                const resolveHandle = scope.manage(this.newFunction(\"resolve\", (value)=>{\n                    resolve({\n                        value: value && value.dup()\n                    });\n                }));\n                const rejectHandle = scope.manage(this.newFunction(\"reject\", (error)=>{\n                    resolve({\n                        error: error && error.dup()\n                    });\n                }));\n                const promiseHandle = scope.manage(vmResolveResult.value);\n                const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"));\n                this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();\n            });\n        });\n    }\n    // Properties ---------------------------------------------------------------\n    /**\n     * `handle[key]`.\n     * Get a property from a JSValue.\n     *\n     * @param key - The property may be specified as a JSValue handle, or as a\n     * Javascript string (which will be converted automatically).\n     */ getProp(handle, key) {\n        this.runtime.assertOwned(handle);\n        const ptr = this.borrowPropertyKey(key).consume((quickJSKey)=>this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value));\n        const result = this.memory.heapValueHandle(ptr);\n        return result;\n    }\n    /**\n     * `handle[key] = value`.\n     * Set a property on a JSValue.\n     *\n     * @remarks\n     * Note that the QuickJS authors recommend using [[defineProp]] to define new\n     * properties.\n     *\n     * @param key - The property may be specified as a JSValue handle, or as a\n     * Javascript string or number (which will be converted automatically to a JSValue).\n     */ setProp(handle, key, value) {\n        this.runtime.assertOwned(handle);\n        // free newly allocated value if key was a string or number. No-op if string was already\n        // a QuickJS handle.\n        this.borrowPropertyKey(key).consume((quickJSKey)=>this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value));\n    }\n    /**\n     * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n     *\n     * @param key - The property may be specified as a JSValue handle, or as a\n     * Javascript string or number (which will be converted automatically to a JSValue).\n     */ defineProp(handle, key, descriptor) {\n        this.runtime.assertOwned(handle);\n        $bi2gA.Scope.withScope((scope)=>{\n            const quickJSKey = scope.manage(this.borrowPropertyKey(key));\n            const value = descriptor.value || this.undefined;\n            const configurable = Boolean(descriptor.configurable);\n            const enumerable = Boolean(descriptor.enumerable);\n            const hasValue = Boolean(descriptor.value);\n            const get = descriptor.get ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get)) : this.undefined;\n            const set = descriptor.set ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set)) : this.undefined;\n            this.ffi.QTS_DefineProp(this.ctx.value, handle.value, quickJSKey.value, value.value, get.value, set.value, configurable, enumerable, hasValue);\n        });\n    }\n    // Evaluation ---------------------------------------------------------------\n    /**\n     * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n     * Call a JSValue as a function.\n     *\n     * See [[unwrapResult]], which will throw if the function returned an error, or\n     * return the result handle directly. If evaluation returned a handle containing\n     * a promise, use [[resolvePromise]] to convert it to a native promise and\n     * [[executePendingJobs]] to finish evaluating the promise.\n     *\n     * @returns A result. If the function threw synchronously, `result.error` be a\n     * handle to the exception. Otherwise `result.value` will be a handle to the\n     * value.\n     */ callFunction(func, thisVal, ...args) {\n        this.runtime.assertOwned(func);\n        const resultPtr = this.memory.toPointerArray(args).consume((argsArrayPtr)=>this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));\n        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n        if (errorPtr) {\n            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n            return {\n                error: this.memory.heapValueHandle(errorPtr)\n            };\n        }\n        return {\n            value: this.memory.heapValueHandle(resultPtr)\n        };\n    }\n    /**\n     * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n     * Evaluates the Javascript source `code` in the global scope of this VM.\n     * When working with async code, you many need to call [[executePendingJobs]]\n     * to execute callbacks pending after synchronous evaluation returns.\n     *\n     * See [[unwrapResult]], which will throw if the function returned an error, or\n     * return the result handle directly. If evaluation returned a handle containing\n     * a promise, use [[resolvePromise]] to convert it to a native promise and\n     * [[executePendingJobs]] to finish evaluating the promise.\n     *\n     * *Note*: to protect against infinite loops, provide an interrupt handler to\n     * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n     * create a time-based deadline.\n     *\n     * @returns The last statement's value. If the code threw synchronously,\n     * `result.error` will be a handle to the exception. If execution was\n     * interrupted, the error will have name `InternalError` and message\n     * `interrupted`.\n     */ evalCode(code, filename = \"eval.js\", /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See [[EvalFlags]] for number semantics.\n     */ options) {\n        const detectModule = options === undefined ? 1 : 0;\n        const flags = (0, $b4QHs.evalOptionsToFlags)(options);\n        const resultPtr = this.memory.newHeapCharPointer(code).consume((charHandle)=>this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));\n        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n        if (errorPtr) {\n            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n            return {\n                error: this.memory.heapValueHandle(errorPtr)\n            };\n        }\n        return {\n            value: this.memory.heapValueHandle(resultPtr)\n        };\n    }\n    /**\n     * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n     * @experimental\n     */ throw(error) {\n        return this.errorToHandle(error).consume((handle)=>this.ffi.QTS_Throw(this.ctx.value, handle.value));\n    }\n    /**\n     * @private\n     */ borrowPropertyKey(key) {\n        if (typeof key === \"number\") return this.newNumber(key);\n        if (typeof key === \"string\") return this.newString(key);\n        // key is already a JSValue, but we're borrowing it. Return a static handle\n        // for internal use only.\n        return new $bi2gA.StaticLifetime(key.value, this.runtime);\n    }\n    /**\n     * @private\n     */ getMemory(rt) {\n        if (rt === this.rt.value) return this.memory;\n        else throw new Error(\"Private API. Cannot get memory from a different runtime\");\n    }\n    // Utilities ----------------------------------------------------------------\n    /**\n     * Dump a JSValue to Javascript in a best-effort fashion.\n     * Returns `handle.toString()` if it cannot be serialized to JSON.\n     */ dump(handle) {\n        this.runtime.assertOwned(handle);\n        const type = this.typeof(handle);\n        if (type === \"string\") return this.getString(handle);\n        else if (type === \"number\") return this.getNumber(handle);\n        else if (type === \"bigint\") return this.getBigInt(handle);\n        else if (type === \"undefined\") return undefined;\n        else if (type === \"symbol\") return this.getSymbol(handle);\n        const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value));\n        try {\n            return JSON.parse(str);\n        } catch (err) {\n            return str;\n        }\n    }\n    /**\n     * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n     * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n     * If the result is a success, returns the value.\n     * If the result is an error, converts the error to a native object and throws the error.\n     */ unwrapResult(result) {\n        if (result.error) {\n            const context = \"context\" in result.error ? result.error.context : this;\n            const cause = result.error.consume((error)=>this.dump(error));\n            if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n                const { message: message, name: name, stack: stack } = cause;\n                const exception = new $1ODqT.QuickJSUnwrapError(\"\");\n                const hostStack = exception.stack;\n                if (typeof name === \"string\") exception.name = cause.name;\n                if (typeof stack === \"string\") exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`;\n                Object.assign(exception, {\n                    cause: cause,\n                    context: context,\n                    message: message\n                });\n                throw exception;\n            }\n            throw new $1ODqT.QuickJSUnwrapError(cause, context);\n        }\n        return result.value;\n    }\n    /** @private */ getFunction(fn_id) {\n        const map_id = fn_id >> 8;\n        const fnMap = this.fnMaps.get(map_id);\n        if (!fnMap) return undefined;\n        return fnMap.get(fn_id);\n    }\n    /** @private */ setFunction(fn_id, handle) {\n        const map_id = fn_id >> 8;\n        let fnMap = this.fnMaps.get(map_id);\n        if (!fnMap) {\n            fnMap = new Map();\n            this.fnMaps.set(map_id, fnMap);\n        }\n        return fnMap.set(fn_id, handle);\n    }\n    errorToHandle(error) {\n        if (error instanceof $bi2gA.Lifetime) return error;\n        return this.newError(error);\n    }\n}\nmodule.exports.QuickJSContext = $4be592c2b41fac6d$var$QuickJSContext;\n\n});\nparcelRegister(\"2CmkI\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.ModuleMemory = void 0;\n\nvar $bi2gA = parcelRequire(\"bi2gA\");\n/**\n * @private\n */ class $1e807442422e6b2f$var$ModuleMemory {\n    constructor(module){\n        this.module = module;\n    }\n    toPointerArray(handleArray) {\n        const typedArray = new Int32Array(handleArray.map((handle)=>handle.value));\n        const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;\n        const ptr = this.module._malloc(numBytes);\n        var heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes);\n        heapBytes.set(new Uint8Array(typedArray.buffer));\n        return new $bi2gA.Lifetime(ptr, undefined, (ptr)=>this.module._free(ptr));\n    }\n    newMutablePointerArray(length) {\n        const zeros = new Int32Array(new Array(length).fill(0));\n        const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT;\n        const ptr = this.module._malloc(numBytes);\n        const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length);\n        typedArray.set(zeros);\n        return new $bi2gA.Lifetime({\n            typedArray: typedArray,\n            ptr: ptr\n        }, undefined, (value)=>this.module._free(value.ptr));\n    }\n    newHeapCharPointer(string) {\n        const numBytes = this.module.lengthBytesUTF8(string) + 1;\n        const ptr = this.module._malloc(numBytes);\n        this.module.stringToUTF8(string, ptr, numBytes);\n        return new $bi2gA.Lifetime(ptr, undefined, (value)=>this.module._free(value));\n    }\n    consumeHeapCharPointer(ptr) {\n        const str = this.module.UTF8ToString(ptr);\n        this.module._free(ptr);\n        return str;\n    }\n}\nmodule.exports.ModuleMemory = $1e807442422e6b2f$var$ModuleMemory;\n\n});\n\nparcelRegister(\"b4QHs\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.concat = module.exports.evalOptionsToFlags = module.exports.DefaultIntrinsics = void 0;\n\nvar $jVdaX = parcelRequire(\"jVdaX\");\nconst $8108f28cf5fbd0fa$var$UnstableSymbol = Symbol(\"Unstable\");\n// For informational purposes\nconst $8108f28cf5fbd0fa$var$DefaultIntrinsicsList = [\n    \"BaseObjects\",\n    \"Date\",\n    \"Eval\",\n    \"StringNormalize\",\n    \"RegExp\",\n    \"JSON\",\n    \"Proxy\",\n    \"MapSet\",\n    \"TypedArrays\",\n    \"Promise\"\n];\n/**\n * Work in progress.\n */ module.exports.DefaultIntrinsics = Symbol(\"DefaultIntrinsics\");\n/** Convert [[ContextEvalOptions]] to a bitfield flags */ function $8108f28cf5fbd0fa$var$evalOptionsToFlags(evalOptions) {\n    if (typeof evalOptions === \"number\") return evalOptions;\n    if (evalOptions === undefined) return 0;\n    const { type: type, strict: strict, strip: strip, compileOnly: compileOnly, backtraceBarrier: backtraceBarrier } = evalOptions;\n    let flags = 0;\n    if (type === \"global\") flags |= $jVdaX.EvalFlags.JS_EVAL_TYPE_GLOBAL;\n    if (type === \"module\") flags |= $jVdaX.EvalFlags.JS_EVAL_TYPE_MODULE;\n    if (strict) flags |= $jVdaX.EvalFlags.JS_EVAL_FLAG_STRICT;\n    if (strip) flags |= $jVdaX.EvalFlags.JS_EVAL_FLAG_STRIP;\n    if (compileOnly) flags |= $jVdaX.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY;\n    if (backtraceBarrier) flags |= $jVdaX.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER;\n    return flags;\n}\nmodule.exports.evalOptionsToFlags = $8108f28cf5fbd0fa$var$evalOptionsToFlags;\nfunction $8108f28cf5fbd0fa$var$concat(...values) {\n    let result = [];\n    for (const value of values)if (value !== undefined) result = result.concat(value);\n    return result;\n}\nmodule.exports.concat = $8108f28cf5fbd0fa$var$concat;\n\n});\nparcelRegister(\"jVdaX\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.EvalFlags = module.exports.assertSync = void 0;\nfunction $e80d8fa0d7a4c484$var$assertSync(fn) {\n    return function mustBeSync(...args) {\n        const result = fn(...args);\n        if (result && typeof result === \"object\" && result instanceof Promise) throw new Error(\"Function unexpectedly returned a Promise\");\n        return result;\n    };\n}\nmodule.exports.assertSync = $e80d8fa0d7a4c484$var$assertSync;\n/** Bitfield options for JS_Eval() C function. */ module.exports.EvalFlags = {\n    /** global code (default) */ JS_EVAL_TYPE_GLOBAL: 0,\n    /** module code */ JS_EVAL_TYPE_MODULE: 1,\n    /** direct call (internal use) */ JS_EVAL_TYPE_DIRECT: 2,\n    /** indirect call (internal use) */ JS_EVAL_TYPE_INDIRECT: 3,\n    JS_EVAL_TYPE_MASK: 3,\n    /** force 'strict' mode */ JS_EVAL_FLAG_STRICT: 8,\n    /** force 'strip' mode */ JS_EVAL_FLAG_STRIP: 16,\n    /**\n     * compile but do not run. The result is an object with a\n     * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n     * with JS_EvalFunction().\n     */ JS_EVAL_FLAG_COMPILE_ONLY: 32,\n    /** don't include the stack frames before this eval in the Error() backtraces */ JS_EVAL_FLAG_BACKTRACE_BARRIER: 64\n};\n\n});\n\n\n\n\n\n\n//# sourceMappingURL=module.7cbe2af9.js.map\n",null,"import { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport {\n  Asyncify,\n  AsyncifySleepResult,\n  EitherModule,\n  EmscriptenModuleCallbacks,\n} from \"./emscripten-types\"\nimport { QuickJSAsyncifyError, QuickJSAsyncifySuspended } from \"./errors\"\nimport {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValuePointer,\n} from \"./types-ffi\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport {\n  AsyncRuntimeOptions,\n  concat,\n  ContextOptions,\n  EitherFFI,\n  JSModuleLoader,\n  RuntimeOptions,\n  RuntimeOptionsBase,\n} from \"./types\"\n\ntype EmscriptenCallback<BaseArgs extends any[], Result> = (\n  ...args: [Asyncify | undefined, ...BaseArgs]\n) => Result | AsyncifySleepResult<Result>\ntype MaybeAsyncEmscriptenCallback<T extends EmscriptenCallback<any, any>> =\n  T extends EmscriptenCallback<infer Args, infer Result>\n    ? (...args: Args) => Result | Promise<Result>\n    : never\ntype MaybeAsyncEmscriptenCallbacks = {\n  [K in keyof EmscriptenModuleCallbacks]: MaybeAsyncEmscriptenCallback<EmscriptenModuleCallbacks[K]>\n}\n\n/**\n * @private\n */\nexport interface ContextCallbacks {\n  callFunction: MaybeAsyncEmscriptenCallbacks[\"callFunction\"]\n}\n\n/**\n * @private\n */\nexport interface RuntimeCallbacks {\n  shouldInterrupt: MaybeAsyncEmscriptenCallbacks[\"shouldInterrupt\"]\n  loadModuleSource: MaybeAsyncEmscriptenCallbacks[\"loadModuleSource\"]\n  normalizeModule: MaybeAsyncEmscriptenCallbacks[\"normalizeModule\"]\n}\n\nclass QuickJSEmscriptenModuleCallbacks implements EmscriptenModuleCallbacks {\n  public callFunction: EmscriptenModuleCallbacks[\"callFunction\"]\n  public shouldInterrupt: EmscriptenModuleCallbacks[\"shouldInterrupt\"]\n  public loadModuleSource: EmscriptenModuleCallbacks[\"loadModuleSource\"]\n  public normalizeModule: EmscriptenModuleCallbacks[\"normalizeModule\"]\n  constructor(args: EmscriptenModuleCallbacks) {\n    this.callFunction = args.callFunction\n    this.shouldInterrupt = args.shouldInterrupt\n    this.loadModuleSource = args.loadModuleSource\n    this.normalizeModule = args.normalizeModule\n  }\n}\n\n/**\n * Options for [[QuickJSWASMModule.evalCode]].\n */\nexport interface ModuleEvalOptions {\n  /**\n   * Interrupt evaluation if `shouldInterrupt` returns `true`.\n   * See [[shouldInterruptAfterDeadline]].\n   */\n  shouldInterrupt?: InterruptHandler\n\n  /**\n   * Memory limit, in bytes, of WebAssembly heap memory used by the QuickJS VM.\n   */\n  memoryLimitBytes?: number\n\n  /**\n   * Stack size limit for this vm, in bytes\n   * To remove the limit, set to `0`.\n   */\n  maxStackSizeBytes?: number\n\n  /**\n   * Module loader for any `import` statements or expressions.\n   */\n  moduleLoader?: JSModuleLoader\n}\n\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nexport class QuickJSModuleCallbacks {\n  private module: EitherModule\n  private contextCallbacks = new Map<JSContextPointer, ContextCallbacks>()\n  private runtimeCallbacks = new Map<JSRuntimePointer, RuntimeCallbacks>()\n\n  constructor(module: EitherModule) {\n    this.module = module\n    this.module.callbacks = this.cToHostCallbacks\n  }\n\n  setRuntimeCallbacks(rt: JSRuntimePointer, callbacks: RuntimeCallbacks) {\n    this.runtimeCallbacks.set(rt, callbacks)\n  }\n\n  deleteRuntime(rt: JSRuntimePointer) {\n    this.runtimeCallbacks.delete(rt)\n  }\n\n  setContextCallbacks(ctx: JSContextPointer, callbacks: ContextCallbacks) {\n    this.contextCallbacks.set(ctx, callbacks)\n  }\n\n  deleteContext(ctx: JSContextPointer) {\n    this.contextCallbacks.delete(ctx)\n  }\n\n  private suspendedCount = 0\n  private suspended: QuickJSAsyncifySuspended | undefined\n\n  private handleAsyncify<T>(\n    asyncify: Asyncify | undefined,\n    fn: () => T | Promise<T>\n  ): T | AsyncifySleepResult<T> {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep((done) => {\n        try {\n          const result = fn()\n          if (!(result instanceof Promise)) {\n            debugLog(\"asyncify.handleSleep: not suspending:\", result)\n            done(result)\n            return\n          }\n\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new QuickJSAsyncifyError(\n              `Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`\n            )\n          } else {\n            this.suspended = new QuickJSAsyncifySuspended(`(${this.suspendedCount++})`)\n            debugLog(\"asyncify.handleSleep: suspending:\", this.suspended)\n          }\n\n          result.then(\n            (resolvedResult) => {\n              this.suspended = undefined\n              debugLog(\"asyncify.handleSleep: resolved:\", resolvedResult)\n              done(resolvedResult)\n            },\n            (error) => {\n              debugLog(\"asyncify.handleSleep: rejected:\", error)\n              console.error(\"QuickJS: cannot handle error in suspended function\", error)\n              this.suspended = undefined\n            }\n          )\n        } catch (error) {\n          debugLog(\"asyncify.handleSleep: error:\", error)\n          this.suspended = undefined\n          throw error\n        }\n      })\n    }\n\n    // No asyncify - we should never return a promise.\n    const value = fn()\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\")\n    }\n    return value\n  }\n\n  private cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n    callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx)\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`)\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id)\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error)\n          return 0 as JSValuePointer\n        }\n      }),\n\n    shouldInterrupt: (asyncify, rt) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt)\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`)\n          }\n          return vm.shouldInterrupt(rt)\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error)\n          return 1\n        }\n      }),\n\n    loadModuleSource: (asyncify, rt, ctx, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const loadModule = runtimeCallbacks.loadModuleSource\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return loadModule(rt, ctx, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n\n    normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const normalizeModule = runtimeCallbacks.normalizeModule\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n  })\n}\n\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyBaseRuntimeOptions(\n  runtime: QuickJSRuntime,\n  options: RuntimeOptionsBase\n): void {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n}\n\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyModuleEvalRuntimeOptions<T extends QuickJSRuntime>(\n  runtime: T,\n  options: ModuleEvalOptions\n) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader)\n  }\n\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n}\n\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nexport class QuickJSWASMModule {\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected module: EitherModule\n\n  /** @private */\n  constructor(module: EitherModule, ffi: EitherFFI) {\n    this.module = module\n    this.ffi = ffi\n    this.callbacks = new QuickJSModuleCallbacks(module)\n  }\n\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more [[QuickJSContext]]s inside the runtime.\n   */\n  newRuntime(options: RuntimeOptions = {}): QuickJSRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n\n    const runtime = new QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const runtime = this.newRuntime()\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: concat(runtime, options.ownedLifetimes),\n    })\n    runtime.context = context\n    return context\n  }\n\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntime]] or\n   * [[QuickJSContext]] explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with\n   * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its\n   * [[QuickJSContext.evalCode]] method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * [[QuickJSRuntime.executePendingJobs]].\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code: string, options: ModuleEvalOptions = {}): unknown {\n    return Scope.withScope((scope) => {\n      const vm = scope.manage(this.newContext())\n\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = vm.evalCode(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI(): EitherFFI {\n    return this.ffi\n  }\n}\n",null,"import { maybeAsyncFn } from \"./asyncify-helpers\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { EitherModule } from \"./emscripten-types\"\nimport { QuickJSWrongOwner } from \"./errors\"\nimport {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSContextPointerPointer,\n  JSModuleDefPointer,\n  JSRuntimePointer,\n} from \"./types-ffi\"\nimport { Disposable, Lifetime, Scope } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport { QuickJSModuleCallbacks, RuntimeCallbacks } from \"./module\"\nimport {\n  ContextOptions,\n  DefaultIntrinsics,\n  EitherFFI,\n  JSModuleLoader,\n  JSModuleNormalizer,\n  QuickJSHandle,\n} from \"./types\"\nimport { SuccessOrFail } from \"./vm-interface\"\n\n/**\n * Callback called regularly while the VM executes code.\n * Determines if a VM's execution should be interrupted.\n *\n * @returns `true` to interrupt JS execution inside the VM.\n * @returns `false` or `undefined` to continue JS execution inside the VM.\n */\nexport type InterruptHandler = (runtime: QuickJSRuntime) => boolean | undefined\n\n/**\n * Used as an optional for the results of executing pendingJobs.\n * On success, `value` contains the number of async jobs executed\n * by the runtime.\n * @source\n */\nexport type ExecutePendingJobsResult = SuccessOrFail<\n  /** Number of jobs successfully executed. */\n  number,\n  /** The error that occurred. */\n  QuickJSHandle & {\n    /** The context where the error occurred. */\n    context: QuickJSContext\n  }\n>\n\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with [[setInterruptHandler]]\n * (called regularly while the interpreter runs), [[setMemoryLimit]], and\n * [[setMaxStackSize]].\n * Use [[computeMemoryUsage]] or [[dumpMemoryUsage]] to guide memory limit\n * tuning.\n *\n * Configure ES module loading with [[setModuleLoader]].\n */\nexport class QuickJSRuntime implements Disposable {\n  /**\n   * If this runtime was created as as part of a context, points to the context\n   * associated with the runtime.\n   *\n   * If this runtime was created stand-alone, this may or may not contain a context.\n   * A context here may be allocated if one is needed by the runtime, eg for [[computeMemoryUsage]].\n   */\n  public context: QuickJSContext | undefined\n\n  /** @private */\n  protected module: EitherModule\n  /** @private */\n  protected memory: ModuleMemory\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected scope = new Scope()\n\n  /** @private */\n  protected contextMap = new Map<JSContextPointer, QuickJSContext>()\n  /** @private */\n  protected moduleLoader: JSModuleLoader | undefined\n  /** @private */\n  protected moduleNormalizer: JSModuleNormalizer | undefined\n\n  /** @private */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n    ownedLifetimes?: Disposable[]\n  }) {\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.module = args.module\n    this.memory = new ModuleMemory(this.module)\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.callbacks = args.callbacks\n    this.scope.manage(this.rt)\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks)\n\n    this.executePendingJobs = this.executePendingJobs.bind(this)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    if (options.intrinsics && options.intrinsics !== DefaultIntrinsics) {\n      throw new Error(\"TODO: Custom intrinsics are not supported yet\")\n    }\n\n    const ctx = new Lifetime(\n      options.contextPointer || this.ffi.QTS_NewContext(this.rt.value),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      }\n    )\n\n    const context = new QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with [[removeModuleLoader]].\n   */\n  setModuleLoader(moduleLoader: JSModuleLoader, moduleNormalizer?: JSModuleNormalizer): void {\n    this.moduleLoader = moduleLoader\n    this.moduleNormalizer = moduleNormalizer\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0)\n  }\n\n  /**\n   * Remove the the loader set by [[setModuleLoader]]. This disables module loading.\n   */\n  removeModuleLoader(): void {\n    this.moduleLoader = undefined\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)\n  }\n\n  // Runtime management -------------------------------------------------------\n\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling [[executePendingJobs]].\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob(): boolean {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value))\n  }\n\n  private interruptHandler: InterruptHandler | undefined\n\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with [[removeInterruptHandler]].\n   */\n  setInterruptHandler(cb: InterruptHandler) {\n    const prevInterruptHandler = this.interruptHandler\n    this.interruptHandler = cb\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)\n    }\n  }\n\n  /**\n   * Remove the interrupt handler, if any.\n   * See [[setInterruptHandler]].\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value)\n      this.interruptHandler = undefined\n    }\n  }\n\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * [[resolvePromise]] on the promise handle returned by the async function.\n   */\n  executePendingJobs(maxJobsToExecute: number | void = -1): ExecutePendingJobsResult {\n    const ctxPtrOut = this.memory.newMutablePointerArray<JSContextPointerPointer>(1)\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(\n      this.rt.value,\n      maxJobsToExecute ?? -1,\n      ctxPtrOut.value.ptr\n    )\n\n    const ctxPtr = ctxPtrOut.value.typedArray[0] as JSContextPointer\n    ctxPtrOut.dispose()\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr)\n      return { value: 0 }\n    }\n\n    const context =\n      this.contextMap.get(ctxPtr) ??\n      this.newContext({\n        contextPointer: ctxPtr,\n      })\n\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr)\n    const typeOfRet = context.typeof(resultValue)\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue)\n      resultValue.dispose()\n      return { value: executedJobs }\n    } else {\n      const error = Object.assign(resultValue, { context })\n      return {\n        error,\n      }\n    }\n  }\n\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes: number) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\")\n    }\n\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes)\n  }\n\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see [[dumpMemoryUsage]].\n   */\n  computeMemoryUsage(): QuickJSHandle {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value)\n    return serviceContextMemory.heapValueHandle(\n      this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value)\n    )\n  }\n\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see [[computeMemoryUsage]].\n   */\n  dumpMemoryUsage(): string {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))\n  }\n\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize: number) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\")\n    }\n\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize)\n  }\n\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle: QuickJSHandle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new QuickJSWrongOwner(\n        `Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`\n      )\n    }\n  }\n\n  private getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext())\n    }\n    return this.context\n  }\n\n  private cToHostCallbacks: RuntimeCallbacks = {\n    shouldInterrupt: (rt) => {\n      if (rt !== this.rt.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\")\n      }\n\n      const fn = this.interruptHandler\n      if (!fn) {\n        throw new Error(\"QuickJSContext had no interrupt handler\")\n      }\n\n      return fn(this) ? 1 : 0\n    },\n\n    loadModuleSource: maybeAsyncFn(this, function* (awaited, rt, ctx, moduleName) {\n      const moduleLoader = this.moduleLoader\n      if (!moduleLoader) {\n        throw new Error(\"Runtime has no module loader\")\n      }\n\n      if (rt !== this.rt.value) {\n        throw new Error(\"Runtime pointer mismatch\")\n      }\n\n      const context =\n        this.contextMap.get(ctx) ??\n        this.newContext({\n          contextPointer: ctx,\n        })\n\n      try {\n        const result = yield* awaited(moduleLoader(moduleName, context))\n\n        if (typeof result === \"object\" && \"error\" in result && result.error) {\n          debugLog(\"cToHostLoadModule: loader returned error\", result.error)\n          throw result.error\n        }\n\n        const moduleSource =\n          typeof result === \"string\" ? result : \"value\" in result ? result.value : result\n\n        return this.memory.newHeapCharPointer(moduleSource).value\n      } catch (error) {\n        debugLog(\"cToHostLoadModule: caught error\", error)\n        context.throw(error as any)\n        return 0 as BorrowedHeapCharPointer\n      }\n    }),\n\n    normalizeModule: maybeAsyncFn(\n      this,\n      function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\")\n        }\n\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\")\n        }\n\n        const context =\n          this.contextMap.get(ctx) ??\n          this.newContext({\n            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n            contextPointer: ctx,\n          })\n\n        try {\n          const result = yield* awaited(\n            moduleNormalizer(baseModuleName, moduleNameRequest, context)\n          )\n\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            debugLog(\"cToHostNormalizeModule: normalizer returned error\", result.error)\n            throw result.error\n          }\n\n          const name = typeof result === \"string\" ? result : result.value\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value\n        } catch (error) {\n          debugLog(\"normalizeModule: caught error\", error)\n          context.throw(error as any)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }\n    ),\n  }\n}\n",null,"import { debugLog } from \"./debug\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\nimport type { EitherModule } from \"./emscripten-types\"\nimport { QuickJSUnwrapError } from \"./errors\"\nimport {\n  EvalDetectModule,\n  EvalFlags,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSModuleDefPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"./types-ffi\"\nimport { Disposable, Lifetime, Scope, StaticLifetime, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport {\n  ContextEvalOptions,\n  EitherFFI,\n  evalOptionsToFlags,\n  JSValue,\n  PromiseExecutor,\n  QuickJSHandle,\n} from \"./types\"\nimport {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * [[QuickJSContext.getProp]], [[QuickJSContext.setProp]], or [[QuickJSContext.defineProp]].\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext implements LowLevelJavascriptVm<QuickJSHandle>, Disposable {\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle))\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new [[QuickJSDeferredPromise]]. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on [[QuickJSDeferredPromise]] for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new [[QuickJSDeferredPromise]] that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * [[QuickJSDeferredPromise]].\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2)\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any)\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject)\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See [[VmFunctionImplementation]] for more details.\n   *\n   * A [[VmFunctionImplementation]] should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * To implement an async function, create a promise with [[newPromise]], then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle)\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle)\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value)\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          })\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          })\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value)\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using [[defineProp]] to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value)\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value\n        )\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   * Evaluates the Javascript source `code` in the global scope of this VM.\n   * When working with async code, you many need to call [[executePendingJobs]]\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See [[EvalFlags]] for number semantics.\n     */\n    options?: number | ContextEvalOptions\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags)\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value)\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n   * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value)\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n}\n",null,"import { EitherModule } from \"./emscripten-types\"\nimport {\n  OwnedHeapCharPointer,\n  JSContextPointerPointer,\n  JSValueConstPointerPointer,\n  JSValuePointerPointer,\n} from \"./types-ffi\"\nimport { Lifetime } from \"./lifetime\"\nimport { EitherFFI, QuickJSHandle } from \"./types\"\n\n/**\n * @private\n */\nexport class ModuleMemory {\n  constructor(public module: EitherModule) {}\n\n  toPointerArray(handleArray: QuickJSHandle[]): Lifetime<JSValueConstPointerPointer> {\n    const typedArray = new Int32Array(handleArray.map((handle) => handle.value))\n    const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as JSValueConstPointerPointer\n    var heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes)\n    heapBytes.set(new Uint8Array(typedArray.buffer))\n    return new Lifetime(ptr, undefined, (ptr) => this.module._free(ptr))\n  }\n\n  newMutablePointerArray<T extends JSContextPointerPointer | JSValuePointerPointer>(\n    length: number\n  ): Lifetime<{ typedArray: Int32Array; ptr: T }> {\n    const zeros = new Int32Array(new Array(length).fill(0))\n    const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as T\n    const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length)\n    typedArray.set(zeros)\n    return new Lifetime({ typedArray, ptr }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapCharPointer(string: string): Lifetime<OwnedHeapCharPointer> {\n    const numBytes = this.module.lengthBytesUTF8(string) + 1\n    const ptr: OwnedHeapCharPointer = this.module._malloc(numBytes) as OwnedHeapCharPointer\n    this.module.stringToUTF8(string, ptr, numBytes)\n    return new Lifetime(ptr, undefined, (value) => this.module._free(value))\n  }\n\n  consumeHeapCharPointer(ptr: OwnedHeapCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.module._free(ptr)\n    return str\n  }\n}\n",null,"import type { QuickJSFFI, QuickJSAsyncFFI } from \"./variants\"\nimport type { QuickJSContext } from \"./context\"\nimport type { SuccessOrFail, VmFunctionImplementation } from \"./vm-interface\"\nimport type { Disposable, Lifetime } from \"./lifetime\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport { EvalFlags, JSContextPointer, JSValueConstPointer, JSValuePointer } from \"./types-ffi\"\n\nexport type EitherFFI = QuickJSFFI | QuickJSAsyncFFI\n\n/**\n * A QuickJSHandle to a constant that will never change, and does not need to\n * be disposed.\n */\nexport type StaticJSValue = Lifetime<JSValueConstPointer, JSValueConstPointer, QuickJSRuntime>\n\n/**\n * A QuickJSHandle to a borrowed value that does not need to be disposed.\n *\n * In QuickJS, a JSValueConst is a \"borrowed\" reference that isn't owned by the\n * current scope. That means that the current scope should not `JS_FreeValue`\n * it, or retain a reference to it after the scope exits, because it may be\n * freed by its owner.\n *\n * quickjs-emscripten takes care of disposing JSValueConst references.\n */\nexport type JSValueConst = Lifetime<JSValueConstPointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * A owned QuickJSHandle that should be disposed or returned.\n *\n * The QuickJS interpreter passes Javascript values between functions as\n * `JSValue` structs that references some internal data. Because passing\n * structs cross the Empscripten FFI interfaces is bothersome, we use pointers\n * to these structs instead.\n *\n * A JSValue reference is \"owned\" in its scope. before exiting the scope, it\n * should be freed,  by calling `JS_FreeValue(ctx, js_value)`) or returned from\n * the scope. We extend that contract - a JSValuePointer (`JSValue*`) must also\n * be `free`d.\n *\n * You can do so from Javascript by calling the .dispose() method.\n */\nexport type JSValue = Lifetime<JSValuePointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * Wraps a C pointer to a QuickJS JSValue, which represents a Javascript value inside\n * a QuickJS virtual machine.\n *\n * Values must not be shared between QuickJSContext instances.\n * You must dispose of any handles you create by calling the `.dispose()` method.\n */\nexport type QuickJSHandle = StaticJSValue | JSValue | JSValueConst\n\nexport type JSModuleExport =\n  | {\n      type: \"function\"\n      name: string\n      implementation: (vm: QuickJSContext) => VmFunctionImplementation<QuickJSHandle>\n    }\n  | { type: \"value\"; name: string; value: (vm: QuickJSContext) => QuickJSHandle }\n\nexport interface JSModuleDefinition {\n  name: string\n  exports: JSModuleExport[]\n}\n\nexport type JSModuleLoadSuccess = string\nexport type JSModuleLoadFailure = Error | QuickJSHandle\nexport type JSModuleLoadResult =\n  | JSModuleLoadSuccess\n  | SuccessOrFail<JSModuleLoadSuccess, JSModuleLoadFailure>\n\nexport interface JSModuleLoaderAsync {\n  /** Load module (async) */\n  (moduleName: string, context: QuickJSAsyncContext):\n    | JSModuleLoadResult\n    | Promise<JSModuleLoadResult>\n}\nexport interface JSModuleLoader {\n  /** Load module (sync) */\n  (moduleName: string, context: QuickJSContext): JSModuleLoadResult\n}\n\nexport type JSModuleNormalizeSuccess = string\nexport type JSModuleNormalizeFailure = Error | QuickJSHandle\nexport type JSModuleNormalizeResult =\n  | JSModuleNormalizeSuccess\n  | SuccessOrFail<JSModuleNormalizeSuccess, JSModuleNormalizeFailure>\n\nexport interface JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSAsyncContext):\n    | JSModuleNormalizeResult\n    | Promise<JSModuleNormalizeResult>\n}\nexport interface JSModuleNormalizer extends JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSContext): JSModuleNormalizeResult\n}\n\ntype TODO<hint extends string = \"?\", typeHint = unknown> = never\n\nconst UnstableSymbol = Symbol(\"Unstable\")\n\nexport type PartiallyImplemented<T> = never &\n  T & {\n    [UnstableSymbol]: \"This feature may unimplemented, broken, throw errors, etc.\"\n  }\n\nexport interface RuntimeOptionsBase {\n  interruptHandler?: InterruptHandler\n  maxStackSizeBytes?: number\n  memoryLimitBytes?: number\n\n  promiseRejectionHandler?: TODO<\"JSHostPromiseRejectionTracker\">\n  runtimeInfo?: TODO<\"JS_SetRuntimeInfo\", string>\n  gcThreshold?: TODO<\"JS_SetGCThreshold\", number>\n  sharedArrayBufferFunctions?: TODO<\n    \"JS_SetJSSharedArrayBufferFunctions\",\n    { sab_alloc: TODO; sab_free: TODO; sab_dup: TODO; sab_opaque: TODO }\n  >\n\n  /**\n   * Extra lifetimes the runtime should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface RuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoader\n}\n\nexport interface AsyncRuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoaderAsync | JSModuleLoader\n}\n\n/**\n * Work in progress.\n */\nexport type Intrinsic =\n  | \"BaseObjects\"\n  | \"Date\"\n  | \"Eval\"\n  | \"StringNormalize\"\n  | \"RegExp\"\n  | \"RegExpCompiler\"\n  | \"JSON\"\n  | \"Proxy\"\n  | \"MapSet\"\n  | \"TypedArrays\"\n  | \"Promise\"\n  | \"BigInt\"\n  | \"BigFloat\"\n  | \"BigDecimal\"\n  | \"OperatorOverloading\"\n  | \"BignumExt\"\n\n// For informational purposes\nconst DefaultIntrinsicsList = [\n  \"BaseObjects\",\n  \"Date\",\n  \"Eval\",\n  \"StringNormalize\",\n  \"RegExp\",\n  \"JSON\",\n  \"Proxy\",\n  \"MapSet\",\n  \"TypedArrays\",\n  \"Promise\",\n] as const\n\n/**\n * Work in progress.\n */\nexport const DefaultIntrinsics = Symbol(\"DefaultIntrinsics\")\n\nexport interface ContextOptions {\n  /**\n   * What built-in objects and language features to enable?\n   * If unset, the default intrinsics will be used.\n   * To omit all intrinsics, pass an empty array.\n   */\n  intrinsics?: PartiallyImplemented<Intrinsic[]> | typeof DefaultIntrinsics\n\n  /**\n   * Wrap the provided context instead of constructing a new one.\n   * @private\n   */\n  contextPointer?: JSContextPointer\n\n  /**\n   * Extra lifetimes the context should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface ContextEvalOptions {\n  /** Global code (default) */\n  type?: \"global\" | \"module\"\n  /** Force \"strict\" mode */\n  strict?: boolean\n  /** Force \"strip\" mode */\n  strip?: boolean\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  compileOnly?: boolean\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  backtraceBarrier?: boolean\n}\n\n/** Convert [[ContextEvalOptions]] to a bitfield flags */\nexport function evalOptionsToFlags(evalOptions: ContextEvalOptions | number | undefined): number {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions\n  }\n\n  if (evalOptions === undefined) {\n    return 0\n  }\n\n  const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions\n  let flags = 0\n  if (type === \"global\") flags |= EvalFlags.JS_EVAL_TYPE_GLOBAL\n  if (type === \"module\") flags |= EvalFlags.JS_EVAL_TYPE_MODULE\n  if (strict) flags |= EvalFlags.JS_EVAL_FLAG_STRICT\n  if (strip) flags |= EvalFlags.JS_EVAL_FLAG_STRIP\n  if (compileOnly) flags |= EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY\n  if (backtraceBarrier) flags |= EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER\n  return flags\n}\n\nexport type PromiseExecutor<ResolveT, RejectT> = (\n  resolve: (value: ResolveT | PromiseLike<ResolveT>) => void,\n  reject: (reason: RejectT) => void\n) => void\n\nexport function concat<T>(...values: Array<T[] | T | undefined>): T[] {\n  let result: T[] = []\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value)\n    }\n  }\n  return result\n}\n",null,"/**\n * C pointer to type `CType`. Pointer types are used internally for FFI, but\n * are not intended for external use.\n *\n * @unstable This type is considered private and may change.\n */\ntype Pointer<CType extends string> = number & { ctype: CType }\n\ntype Brand<T, B> = T & { brand: B }\n\n/**\n * `JSRuntime*`.\n */\nexport type JSRuntimePointer = Pointer<\"JSRuntime\">\n\n/**\n * `JSContext*`.\n */\nexport type JSContextPointer = Pointer<\"JSContext\">\n\n/**\n * `JSContext**`. Used internally for execute pending jobs.\n */\nexport type JSContextPointerPointer = Pointer<\"JSContext\">\n\n/**\n * `JSModuleDef*`.\n */\nexport type JSModuleDefPointer = Pointer<\"JSModuleDef\">\n\n/**\n * `JSValue*`.\n * See [[JSValue]].\n */\nexport type JSValuePointer = Pointer<\"JSValue\">\n\n/**\n * `JSValueConst*\n * See [[JSValueConst]] and [[StaticJSValue]].\n */\nexport type JSValueConstPointer = Pointer<\"JSValueConst\">\n\n/**\n * Used internally for Javascript-to-C function calls.\n */\nexport type JSValuePointerPointer = Pointer<\"JSValue[]\">\n\n/**\n * Used internally for Javascript-to-C function calls.\n */\nexport type JSValueConstPointerPointer = Pointer<\"JSValueConst[]\">\n\n/**\n * Used internally for C-to-Javascript function calls.\n */\n// type JSCFunctionPointer = Pointer<'JSCFunction'>\n\n/**\n * Used internally for C-to-Javascript function calls.\n */\nexport type QTS_C_To_HostCallbackFuncPointer = Pointer<\"C_To_HostCallbackFunc\">\n\n/**\n * Used internally for C-to-Javascript interrupt handlers.\n */\nexport type QTS_C_To_HostInterruptFuncPointer = Pointer<\"C_To_HostInterruptFunc\">\n\n/**\n * Used internally for C-to-Javascript module loading.\n */\nexport type QTS_C_To_HostLoadModuleFuncPointer = Pointer<\"C_To_HostLoadModuleFunc\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type BorrowedHeapCharPointer = Pointer<\"const char\" | \"char\" | \"js const char\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type OwnedHeapCharPointer = Pointer<\"char\">\n\n/**\n * Used internally for Javascript-to-C calls that may contain strings too large\n * for the Emscripten stack.\n */\nexport type JSBorrowedCharPointer = Pointer<\"js const char\">\n\n/**\n * Opaque pointer that was allocated by js_malloc.\n */\nexport type JSVoidPointer = Pointer<any>\n\n/**\n * @private\n */\nexport type EvalFlags = Brand<number, \"EvalFlags\">\n\n/**\n * @private\n */\nexport type EvalDetectModule = Brand<number, \"EvalDetectModule\">\n\nexport function assertSync<Args extends any[], R>(fn: (...args: Args) => R): (...args: Args) => R {\n  return function mustBeSync(...args: Args): R {\n    const result = fn(...args)\n    if (result && typeof result === \"object\" && result instanceof Promise) {\n      throw new Error(\"Function unexpectedly returned a Promise\")\n    }\n    return result\n  }\n}\n\n/** Bitfield options for JS_Eval() C function. */\nexport const EvalFlags = {\n  /** global code (default) */\n  JS_EVAL_TYPE_GLOBAL: 0 << 0,\n  /** module code */\n  JS_EVAL_TYPE_MODULE: 1 << 0,\n  /** direct call (internal use) */\n  JS_EVAL_TYPE_DIRECT: 2 << 0,\n  /** indirect call (internal use) */\n  JS_EVAL_TYPE_INDIRECT: 3 << 0,\n  JS_EVAL_TYPE_MASK: 3 << 0,\n  /** force 'strict' mode */\n  JS_EVAL_FLAG_STRICT: 1 << 3,\n  /** force 'strip' mode */\n  JS_EVAL_FLAG_STRIP: 1 << 4,\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  JS_EVAL_FLAG_COMPILE_ONLY: 1 << 5,\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  JS_EVAL_FLAG_BACKTRACE_BARRIER: 1 << 6,\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","Object","defineProperty","value","QuickJSWASMModule","applyModuleEvalRuntimeOptions","applyBaseRuntimeOptions","QuickJSModuleCallbacks","$6g0BN","$1ODqT","$bi2gA","$dHRyi","$b4QHs","$5048e3e70162010f$var$QuickJSEmscriptenModuleCallbacks","constructor","args","callFunction","shouldInterrupt","loadModuleSource","normalizeModule","$5048e3e70162010f$var$QuickJSModuleCallbacks","contextCallbacks","Map","runtimeCallbacks","suspendedCount","cToHostCallbacks","asyncify","ctx","this_ptr","argc","argv","fn_id","handleAsyncify","vm","get","Error","error","console","rt","moduleName","loadModule","moduleBaseName","callbacks","setRuntimeCallbacks","set","deleteRuntime","delete","setContextCallbacks","deleteContext","fn","handleSleep","done","result","Promise","debugLog","suspended","QuickJSAsyncifyError","stack","QuickJSAsyncifySuspended","then","resolvedResult","undefined","$5048e3e70162010f$var$applyBaseRuntimeOptions","runtime","options","interruptHandler","setInterruptHandler","maxStackSizeBytes","setMaxStackSize","memoryLimitBytes","setMemoryLimit","$5048e3e70162010f$var$applyModuleEvalRuntimeOptions","moduleLoader","setModuleLoader","ffi","newRuntime","Lifetime","QTS_NewRuntime","rt_ptr","QTS_FreeRuntime","QuickJSRuntime","newContext","context","ownedLifetimes","concat","evalCode","code","Scope","withScope","scope","manage","dump","getFFI","$1kGDh","$6vZNq","$2CmkI","contextMap","maybeAsyncFn","awaited","contextPointer","moduleSource","memory","newHeapCharPointer","throw","baseModuleName","moduleNameRequest","moduleNormalizer","name","getMemory","forEach","lifetime","ModuleMemory","executePendingJobs","bind","alive","dispose","intrinsics","DefaultIntrinsics","QTS_NewContext","ctx_ptr","QTS_FreeContext","QuickJSContext","QTS_RuntimeEnableModuleLoader","removeModuleLoader","QTS_RuntimeDisableModuleLoader","hasPendingJob","Boolean","QTS_IsJobPending","cb","prevInterruptHandler","QTS_RuntimeEnableInterruptHandler","removeInterruptHandler","QTS_RuntimeDisableInterruptHandler","maxJobsToExecute","ctxPtrOut","newMutablePointerArray","valuePtr","QTS_ExecutePendingJob","ptr","ctxPtr","typedArray","QTS_FreeValuePointerRuntime","resultValue","heapValueHandle","typeOfRet","typeof","assign","executedJobs","getNumber","limitBytes","QTS_RuntimeSetMemoryLimit","computeMemoryUsage","serviceContextMemory","getSystemContext","QTS_RuntimeComputeMemoryUsage","dumpMemoryUsage","consumeHeapCharPointer","QTS_RuntimeDumpMemoryUsage","stackSize","QTS_RuntimeSetMaxStackSize","assertOwned","handle","owner","QuickJSWrongOwner","$hHSpR","$4be592c2b41fac6d$var$ContextMemory","copyJSValue","QTS_DupValuePointer","freeJSValue","QTS_FreeValuePointer","consumeJSCharPointer","str","UTF8ToString","QTS_FreeCString","_undefined","_null","_false","_true","_global","_BigInt","fnNextId","fnMaps","getFunction","withScopeMaybeAsync","thisHandle","WeakLifetime","argHandles","Array","i","QTS_ArgvGetJSValueConstPointer","apply","errorToHandle","consume","errorHandle","QTS_Throw","getString","resolvePromise","QTS_GetUndefined","StaticLifetime","null","QTS_GetNull","true","QTS_GetTrue","false","QTS_GetFalse","global","QTS_GetGlobalObject","newNumber","num","QTS_NewFloat64","newString","charHandle","QTS_NewString","newUniqueSymbol","description","key","QTS_NewSymbol","newSymbolFor","newBigInt","bigIntHandle","getProp","asString","String","unwrapResult","newObject","prototype","QTS_NewObjectProto","QTS_NewObject","newArray","QTS_NewArray","newPromise","deferredPromise","mutablePointerArray","promisePtr","QTS_NewPromiseCapability","promiseHandle","resolveHandle","rejectHandle","from","map","jsvaluePtr","QuickJSDeferredPromise","resolve","reject","newError","newFunction","fnId","setFunction","QTS_NewFunction","QTS_NewError","setProp","message","QTS_Typeof","QTS_GetFloat64","QTS_GetString","getSymbol","QTS_GetSymbolDescriptionOrKey","isGlobal","QTS_IsGlobalSymbol","Symbol","for","getBigInt","BigInt","promiseLikeHandle","vmResolveResult","vmPromise","vmPromiseResolve","dup","promiseThenHandle","borrowPropertyKey","quickJSKey","QTS_GetProp","QTS_SetProp","defineProp","descriptor","configurable","enumerable","hasValue","QTS_DefineProp","func","thisVal","resultPtr","toPointerArray","argsArrayPtr","QTS_Call","length","errorPtr","QTS_ResolveException","filename","detectModule","flags","evalOptionsToFlags","QTS_Eval","type","QTS_Dump","JSON","parse","err","cause","exception","QuickJSUnwrapError","hostStack","fnMap","map_id","handleArray","Int32Array","numBytes","BYTES_PER_ELEMENT","_malloc","heapBytes","Uint8Array","HEAPU8","buffer","_free","zeros","fill","string","lengthBytesUTF8","stringToUTF8","$jVdaX","evalOptions","strict","strip","compileOnly","backtraceBarrier","EvalFlags","JS_EVAL_TYPE_GLOBAL","JS_EVAL_TYPE_MODULE","JS_EVAL_FLAG_STRICT","JS_EVAL_FLAG_STRIP","JS_EVAL_FLAG_COMPILE_ONLY","JS_EVAL_FLAG_BACKTRACE_BARRIER","values","assertSync","JS_EVAL_TYPE_DIRECT","JS_EVAL_TYPE_INDIRECT","JS_EVAL_TYPE_MASK"],"version":3,"file":"module.7cbe2af9.js.map","sourceRoot":"../"}