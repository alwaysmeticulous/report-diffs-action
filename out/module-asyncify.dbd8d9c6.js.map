{"mappings":"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","sources":["<anon>","node_modules/@tootallnate/quickjs-emscripten/dist/module-asyncify.js","node_modules/@tootallnate/quickjs-emscripten/ts/module-asyncify.ts","node_modules/@tootallnate/quickjs-emscripten/dist/runtime-asyncify.js","node_modules/@tootallnate/quickjs-emscripten/ts/runtime-asyncify.ts","node_modules/@tootallnate/quickjs-emscripten/dist/context-asyncify.js","node_modules/@tootallnate/quickjs-emscripten/ts/context-asyncify.ts"],"sourcesContent":["require(\"./module.7cbe2af9.js\");\n\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9Pl9k\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSAsyncWASMModule = void 0;\n\nvar $1ODqT = parcelRequire(\"1ODqT\");\n\nvar $bi2gA = parcelRequire(\"bi2gA\");\n\nvar $6TlVH = parcelRequire(\"6TlVH\");\n\nvar $jbyKD = parcelRequire(\"jbyKD\");\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */ class $7279484dd335c23f$var$QuickJSAsyncWASMModule extends $6TlVH.QuickJSWASMModule {\n    /** @private */ constructor(module, ffi){\n        super(module, ffi);\n        this.ffi = ffi;\n        this.module = module;\n    }\n    /**\n     * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n     * module are limited to a single async call at a time. For multiple\n     * concurrent async actions, create multiple WebAssembly modules.\n     */ newRuntime(options = {}) {\n        const rt = new $bi2gA.Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr)=>{\n            this.callbacks.deleteRuntime(rt_ptr);\n            this.ffi.QTS_FreeRuntime(rt_ptr);\n        });\n        const runtime = new $jbyKD.QuickJSAsyncRuntime({\n            module: this.module,\n            ffi: this.ffi,\n            rt: rt,\n            callbacks: this.callbacks\n        });\n        (0, $6TlVH.applyBaseRuntimeOptions)(runtime, options);\n        if (options.moduleLoader) runtime.setModuleLoader(options.moduleLoader);\n        return runtime;\n    }\n    /**\n     * A simplified API to create a new [[QuickJSRuntime]] and a\n     * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n     * be disposed when the context is disposed.\n     */ newContext(options = {}) {\n        const runtime = this.newRuntime();\n        const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([\n            runtime\n        ]) : [\n            runtime\n        ];\n        const context = runtime.newContext({\n            ...options,\n            ownedLifetimes: lifetimes\n        });\n        runtime.context = context;\n        return context;\n    }\n    /** Synchronous evalCode is not supported. */ evalCode() {\n        throw new $1ODqT.QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\");\n    }\n    /**\n     * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n     * [[QuickJSContextSync]] explicitly.\n     *\n     * This version allows for asynchronous Ecmascript module loading.\n     *\n     * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n     * **Multiple concurrent async actions is an error.**\n     *\n     * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n     */ evalCodeAsync(code, options) {\n        // TODO: we should really figure out generator for the Promise monad...\n        return $bi2gA.Scope.withScopeAsync(async (scope)=>{\n            const vm = scope.manage(this.newContext());\n            (0, $6TlVH.applyModuleEvalRuntimeOptions)(vm.runtime, options);\n            const result = await vm.evalCodeAsync(code, \"eval.js\");\n            if (options.memoryLimitBytes !== undefined) // Remove memory limit so we can dump the result without exceeding it.\n            vm.runtime.setMemoryLimit(-1);\n            if (result.error) {\n                const error = vm.dump(scope.manage(result.error));\n                throw error;\n            }\n            const value = vm.dump(scope.manage(result.value));\n            return value;\n        });\n    }\n}\nmodule.exports.QuickJSAsyncWASMModule = $7279484dd335c23f$var$QuickJSAsyncWASMModule;\n\n});\nparcelRegister(\"jbyKD\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSAsyncRuntime = void 0;\n\nvar $74WSo = parcelRequire(\"74WSo\");\n\nvar $eGdjB = parcelRequire(\"eGdjB\");\n\nvar $dHRyi = parcelRequire(\"dHRyi\");\n\nvar $b4QHs = parcelRequire(\"b4QHs\");\nclass $df7a00410ff2f048$var$QuickJSAsyncRuntime extends $dHRyi.QuickJSRuntime {\n    /** @private */ constructor(args){\n        super(args);\n    }\n    newContext(options = {}) {\n        if (options.intrinsics && options.intrinsics !== $b4QHs.DefaultIntrinsics) throw new Error(\"TODO: Custom intrinsics are not supported yet\");\n        const ctx = new $74WSo.Lifetime(this.ffi.QTS_NewContext(this.rt.value), undefined, (ctx_ptr)=>{\n            this.contextMap.delete(ctx_ptr);\n            this.callbacks.deleteContext(ctx_ptr);\n            this.ffi.QTS_FreeContext(ctx_ptr);\n        });\n        const context = new $eGdjB.QuickJSAsyncContext({\n            module: this.module,\n            ctx: ctx,\n            ffi: this.ffi,\n            rt: this.rt,\n            ownedLifetimes: [],\n            runtime: this,\n            callbacks: this.callbacks\n        });\n        this.contextMap.set(ctx.value, context);\n        return context;\n    }\n    setModuleLoader(moduleLoader, moduleNormalizer) {\n        super.setModuleLoader(moduleLoader, moduleNormalizer);\n    }\n    /**\n     * Set the max stack size for this runtime in bytes.\n     * To remove the limit, set to `0`.\n     *\n     * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.\n     * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.\n     */ setMaxStackSize(stackSize) {\n        return super.setMaxStackSize(stackSize);\n    }\n}\nmodule.exports.QuickJSAsyncRuntime = $df7a00410ff2f048$var$QuickJSAsyncRuntime;\n\n});\nparcelRegister(\"eGdjB\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.QuickJSAsyncContext = void 0;\n\nvar $6vZNq = parcelRequire(\"6vZNq\");\n\nvar $6g0BN = parcelRequire(\"6g0BN\");\n\nvar $b4QHs = parcelRequire(\"b4QHs\");\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */ class $aaff510906c2f35e$var$QuickJSAsyncContext extends $6vZNq.QuickJSContext {\n    /**\n     * Asyncified version of [[evalCode]].\n     */ async evalCodeAsync(code, filename = \"eval.js\", /** See [[EvalFlags]] for number semantics */ options) {\n        const detectModule = options === undefined ? 1 : 0;\n        const flags = (0, $b4QHs.evalOptionsToFlags)(options);\n        let resultPtr = 0;\n        try {\n            resultPtr = await this.memory.newHeapCharPointer(code).consume((charHandle)=>this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));\n        } catch (error) {\n            (0, $6g0BN.debugLog)(\"QTS_Eval_MaybeAsync threw\", error);\n            throw error;\n        }\n        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n        if (errorPtr) {\n            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n            return {\n                error: this.memory.heapValueHandle(errorPtr)\n            };\n        }\n        return {\n            value: this.memory.heapValueHandle(resultPtr)\n        };\n    }\n    /**\n     * Similar to [[newFunction]].\n     * Convert an async host Javascript function into a synchronous QuickJS function value.\n     *\n     * Whenever QuickJS calls this function, the VM's stack will be unwound while\n     * waiting the async function to complete, and then restored when the returned\n     * promise resolves.\n     *\n     * Asyncified functions must never call other asyncified functions or\n     * `import`, even indirectly, because the stack cannot be unwound twice.\n     *\n     * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n     */ newAsyncifiedFunction(name, fn) {\n        return this.newFunction(name, fn);\n    }\n}\nmodule.exports.QuickJSAsyncContext = $aaff510906c2f35e$var$QuickJSAsyncContext;\n\n});\n\n\n\n\n//# sourceMappingURL=module-asyncify.dbd8d9c6.js.map\n",null,"import { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSNotImplemented } from \"./errors\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport {\n  applyBaseRuntimeOptions,\n  applyModuleEvalRuntimeOptions,\n  ModuleEvalOptions,\n  QuickJSWASMModule,\n} from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { AsyncRuntimeOptions, ContextOptions, RuntimeOptions } from \"./types\"\n\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nexport class QuickJSAsyncWASMModule extends QuickJSWASMModule {\n  /** @private */\n  protected ffi: QuickJSAsyncFFI\n  /** @private */\n  protected module: QuickJSAsyncEmscriptenModule\n\n  /** @private */\n  constructor(module: QuickJSAsyncEmscriptenModule, ffi: QuickJSAsyncFFI) {\n    super(module, ffi)\n    this.ffi = ffi\n    this.module = module\n  }\n\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  override newRuntime(options: AsyncRuntimeOptions = {}): QuickJSAsyncRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n    const runtime = new QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const runtime = this.newRuntime()\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime]\n    const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes })\n    runtime.context = context\n    return context\n  }\n\n  /** Synchronous evalCode is not supported. */\n  override evalCode(): never {\n    throw new QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\")\n  }\n\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n   * [[QuickJSContextSync]] explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n   */\n  evalCodeAsync(code: string, options: ModuleEvalOptions): Promise<unknown> {\n    // TODO: we should really figure out generator for the Promise monad...\n    return Scope.withScopeAsync(async (scope) => {\n      const vm = scope.manage(this.newContext())\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = await vm.evalCodeAsync(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n}\n",null,"import type { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nimport { Lifetime } from \".\"\nimport { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { JSContextPointer, JSRuntimePointer } from \"./types-ffi\"\nimport { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport {\n  ContextOptions,\n  DefaultIntrinsics,\n  JSModuleLoader,\n  JSModuleLoaderAsync,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n} from \"./types\"\n\nexport class QuickJSAsyncRuntime extends QuickJSRuntime {\n  public context: QuickJSAsyncContext | undefined\n\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected declare contextMap: Map<JSContextPointer, QuickJSAsyncContext>\n\n  /** @private */\n  constructor(args: {\n    module: QuickJSAsyncEmscriptenModule\n    ffi: QuickJSAsyncFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super(args)\n  }\n\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    if (options.intrinsics && options.intrinsics !== DefaultIntrinsics) {\n      throw new Error(\"TODO: Custom intrinsics are not supported yet\")\n    }\n\n    const ctx = new Lifetime(this.ffi.QTS_NewContext(this.rt.value), undefined, (ctx_ptr) => {\n      this.contextMap.delete(ctx_ptr)\n      this.callbacks.deleteContext(ctx_ptr)\n      this.ffi.QTS_FreeContext(ctx_ptr)\n    })\n\n    const context = new QuickJSAsyncContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: [],\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  public override setModuleLoader(\n    moduleLoader: JSModuleLoaderAsync,\n    moduleNormalizer?: JSModuleNormalizerAsync\n  ): void {\n    super.setModuleLoader(\n      moduleLoader as JSModuleLoader,\n      moduleNormalizer as JSModuleNormalizer | undefined\n    )\n  }\n\n  /**\n   * Set the max stack size for this runtime in bytes.\n   * To remove the limit, set to `0`.\n   *\n   * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.\n   * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.\n   */\n  public override setMaxStackSize(stackSize: number): void {\n    return super.setMaxStackSize(stackSize)\n  }\n}\n",null,"import { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { EvalDetectModule, EvalFlags, JSRuntimePointer, JSValuePointer } from \"./types-ffi\"\nimport { Lifetime } from \"./lifetime\"\nimport { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { ContextEvalOptions, evalOptionsToFlags, QuickJSHandle } from \"./types\"\nimport { VmCallResult } from \"./vm-interface\"\n\nexport type AsyncFunctionImplementation = (\n  this: QuickJSHandle,\n  ...args: QuickJSHandle[]\n) => Promise<QuickJSHandle | VmCallResult<QuickJSHandle> | void>\n\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nexport class QuickJSAsyncContext extends QuickJSContext {\n  public declare runtime: QuickJSAsyncRuntime\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n\n  /**\n   * Asyncified version of [[evalCode]].\n   */\n  async evalCodeAsync(\n    code: string,\n    filename: string = \"eval.js\",\n    /** See [[EvalFlags]] for number semantics */\n    options?: number | ContextEvalOptions\n  ): Promise<VmCallResult<QuickJSHandle>> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    let resultPtr = 0 as JSValuePointer\n    try {\n      resultPtr = await this.memory\n        .newHeapCharPointer(code)\n        .consume((charHandle) =>\n          this.ffi.QTS_Eval_MaybeAsync(\n            this.ctx.value,\n            charHandle.value,\n            filename,\n            detectModule,\n            flags\n          )\n        )\n    } catch (error) {\n      debugLog(\"QTS_Eval_MaybeAsync threw\", error)\n      throw error\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Similar to [[newFunction]].\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name: string, fn: AsyncFunctionImplementation): QuickJSHandle {\n    return this.newFunction(name, fn as any)\n  }\n}\n"],"names":["require","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","Object","defineProperty","value","QuickJSAsyncWASMModule","$1ODqT","$bi2gA","$6TlVH","$jbyKD","$7279484dd335c23f$var$QuickJSAsyncWASMModule","QuickJSWASMModule","constructor","ffi","newRuntime","options","rt","Lifetime","QTS_NewRuntime","undefined","rt_ptr","callbacks","deleteRuntime","QTS_FreeRuntime","runtime","QuickJSAsyncRuntime","applyBaseRuntimeOptions","moduleLoader","setModuleLoader","newContext","lifetimes","ownedLifetimes","concat","context","evalCode","QuickJSNotImplemented","evalCodeAsync","code","Scope","withScopeAsync","scope","vm","manage","applyModuleEvalRuntimeOptions","result","memoryLimitBytes","setMemoryLimit","error","dump","$74WSo","$eGdjB","$dHRyi","$b4QHs","$df7a00410ff2f048$var$QuickJSAsyncRuntime","QuickJSRuntime","args","intrinsics","DefaultIntrinsics","Error","ctx","QTS_NewContext","ctx_ptr","contextMap","delete","deleteContext","QTS_FreeContext","QuickJSAsyncContext","set","moduleNormalizer","setMaxStackSize","stackSize","$6vZNq","$6g0BN","$aaff510906c2f35e$var$QuickJSAsyncContext","QuickJSContext","filename","detectModule","flags","evalOptionsToFlags","resultPtr","memory","newHeapCharPointer","consume","charHandle","QTS_Eval_MaybeAsync","debugLog","errorPtr","QTS_ResolveException","QTS_FreeValuePointer","heapValueHandle","newAsyncifiedFunction","name","fn","newFunction"],"version":3,"file":"module-asyncify.dbd8d9c6.js.map","sourceRoot":"../"}